<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TomTom Map Display</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://api.tomtom.com/maps-sdk-for-web/cdn/6.x/6.23.0/maps/maps-web.min.js"></script>
    <link rel="stylesheet" href="https://api.tomtom.com/maps-sdk-for-web/cdn/6.x/6.23.0/maps/maps.css">
</head>
<body>
    <div class="menu">
      <h2>Menu</h2>
      <input type="text" id="addressInput" placeholder="Enter address" oninput="getSuggestions(this.value)" />
      <div id="suggestions"></div>
      <input type="color" id="colorPicker" value="#3498db" />
      <button id="addAddressBtn">Add Address</button>
      <ul id="addressList"></ul>
    </div>
    <div id="map" class="map-container"></div>
    <div id="marker-popup" class="marker-popup"></div>

    <script>
        const apiKey = "60VNodsf8hMWrISHkNcXYtbfFycmRhyh";
        let addressData = [];
        let markers = [];
        let routeLayers = [];
        const popup = document.getElementById('marker-popup');

        const map = tt.map({
            key: apiKey,
            container: "map",
            center: [6.4481, 48.1833],
            zoom: 11,
        });

        function createMarkerElement(address, index, total) {
            const element = document.createElement('div');
            
            // Déterminer la classe du marqueur en fonction de sa position
            if (index === 0) {
                element.className = 'marker-start';
            } else if (index === total - 1) {
                element.className = 'marker-end';
            } else {
                element.className = 'marker-middle';
            }
            
            element.addEventListener('mouseenter', (e) => {
                popup.style.display = 'block';
                popup.textContent = address;
                popup.style.left = (e.clientX + 10) + 'px';
                popup.style.top = (e.clientY + 10) + 'px';
            });
            
            element.addEventListener('mouseleave', () => {
                popup.style.display = 'none';
            });
            
            element.addEventListener('mousemove', (e) => {
                popup.style.left = (e.clientX + 10) + 'px';
                popup.style.top = (e.clientY + 10) + 'px';
            });
            
            return element;
        }

        function updateMarkers() {
            markers.forEach(marker => marker.remove());
            markers = [];

            addressData.forEach((address, index) => {
                const markerElement = createMarkerElement(address.text, index, addressData.length);
                const marker = new tt.Marker({ element: markerElement })
                    .setLngLat(address.coordinates)
                    .addTo(map);
                markers.push(marker);
            });
        }

        function deleteAddress(index) {
            addressData.splice(index, 1);
            updateMarkers();
            updateAddressList();
            
            if (addressData.length > 1) {
                redrawRoutes();
            } else {
                clearRoutes();
            }
        }

        function getSuggestions(query) {
            const suggestionDiv = document.getElementById('suggestions');
            suggestionDiv.innerHTML = '';

            if (query.length < 3) return;

            fetch(`https://api.tomtom.com/search/2/search/${query}.json?key=${apiKey}`)
                .then(response => response.json())
                .then(data => {
                    data.results.forEach(suggestion => {
                        const div = document.createElement('div');
                        div.classList.add('suggestion');
                        div.textContent = suggestion.address.freeformAddress;
                        div.onclick = function() {
                            document.getElementById('addressInput').value = suggestion.address.freeformAddress;
                            suggestionDiv.innerHTML = '';
                        };
                        suggestionDiv.appendChild(div);
                    });
                });
        }

        function moveAddress(index, direction) {
            if ((direction === -1 && index === 0) || 
                (direction === 1 && index === addressData.length - 1)) return;

            const newIndex = index + direction;
            [addressData[index], addressData[newIndex]] = [addressData[newIndex], addressData[index]];
            
            updateMarkers();
            updateAddressList();
            redrawRoutes();
        }

        function updateAddressList() {
            const addressList = document.getElementById('addressList');
            addressList.innerHTML = '';

            addressData.forEach((address, index) => {
                const li = document.createElement('li');
                li.className = 'address-item';
                
                const leftButtonGroup = document.createElement('div');
                leftButtonGroup.className = 'button-group';
                
                // Toujours créer le bouton vers le haut
                const upBtn = document.createElement('button');
                upBtn.textContent = '↑';
                upBtn.className = index === 0 ? 'move-btn disabled' : 'move-btn';
                if (index > 0) {
                    upBtn.onclick = (e) => {
                        e.stopPropagation();
                        moveAddress(index, -1);
                    };
                }
                leftButtonGroup.appendChild(upBtn);
                
                li.appendChild(leftButtonGroup);
                
                const addressText = document.createElement('span');
                addressText.className = 'address-text';
                addressText.textContent = address.text;
                li.appendChild(addressText);
                
                const rightButtonGroup = document.createElement('div');
                rightButtonGroup.className = 'button-group';
                
                // Toujours créer le bouton vers le bas
                const downBtn = document.createElement('button');
                downBtn.textContent = '↓';
                downBtn.className = index === addressData.length - 1 ? 'move-btn disabled' : 'move-btn';
                if (index < addressData.length - 1) {
                    downBtn.onclick = (e) => {
                        e.stopPropagation();
                        moveAddress(index, 1);
                    };
                }
                rightButtonGroup.appendChild(downBtn);
                
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = '×';
                deleteBtn.className = 'delete-btn';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    deleteAddress(index);
                };
                rightButtonGroup.appendChild(deleteBtn);
                
                li.appendChild(rightButtonGroup);
                addressList.appendChild(li);
            });
        }

        function clearRoutes() {
            routeLayers.forEach(layerId => {
                if (map.getLayer(layerId)) {
                    map.removeLayer(layerId);
                    map.removeSource(layerId);
                }
            });
            routeLayers = [];
        }

        async function redrawRoutes() {
            clearRoutes();
            
            for (let i = 0; i < addressData.length - 1; i++) {
                const start = addressData[i].coordinates;
                const end = addressData[i + 1].coordinates;
                const routeColor = document.getElementById('colorPicker').value;
                
                try {
                    const response = await fetch(
                        `https://api.tomtom.com/routing/1/calculateRoute/${start[1]},${start[0]}:${end[1]},${end[0]}/json?key=${apiKey}`
                    );
                    const data = await response.json();
                    const route = data.routes[0].legs[0].points.map(point => [point.longitude, point.latitude]);
                    const routeLayerId = 'route' + i;
                    
                    map.addLayer({
                        id: routeLayerId,
                        type: 'line',
                        source: {
                            type: 'geojson',
                            data: {
                                type: 'Feature',
                                geometry: {
                                    type: 'LineString',
                                    coordinates: route,
                                },
                            },
                        },
                        paint: {
                            'line-color': routeColor,
                            'line-width': 6,
                        },
                    });
                    
                    routeLayers.push(routeLayerId);
                } catch (error) {
                    console.error('Error calculating route:', error);
                }
            }
        }

        async function addAddress() {
            const addressInput = document.getElementById('addressInput');
            const address = addressInput.value;
            if (!address) return;

            try {
                const response = await fetch(`https://api.tomtom.com/search/2/search/${address}.json?key=${apiKey}`);
                const data = await response.json();

                if (data.results && data.results.length > 0) {
                    const result = data.results[0];
                    const coordinates = [result.position.lon, result.position.lat];
                    const addressText = result.address.freeformAddress;
                    
                    addressData.push({
                        text: addressText,
                        coordinates: coordinates
                    });

                    updateMarkers();
                    updateAddressList();
                    
                    if (addressData.length > 1) {
                        redrawRoutes();
                    }

                    addressInput.value = '';
                } else {
                    showError("Adresse invalide ou introuvable");
                }
            } catch (error) {
                console.error('Error retrieving address:', error);
                showError("Erreur lors de la recherche de l'adresse");
            }
        }

        function showError(message) {
            alert(message);
        }

        function updateRouteColor(color) {
            if (routeLayers.length > 0) {
                routeLayers.forEach(layerId => {
                    if (map.getLayer(layerId)) {
                        map.setPaintProperty(layerId, 'line-color', color);
                    }
                });
            }
        }

        document.getElementById('colorPicker').addEventListener('change', function(e) {
            updateRouteColor(e.target.value);
        });

        document.getElementById('addAddressBtn').addEventListener('click', addAddress);
    </script>
</body>
</html>